<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>GoldRush vs CoinGecko — Multi-chain</title>
    <style>
      :root {
        --bg: #ffffff;
        --panel: #ffffff;
        --text: #111827;
        --muted: #6b7280;
        --goldrush: #f59e0b;
        --grid: #e5e7eb;
        --bucket-border: #e5e7eb;
        --pill-bg: #f9fafb;
        --pill-border: #e5e7eb;
        --ring-shade: rgba(100,116,139,0.08);
        --sv-bar-w: 3px;
        --sv-gap:   3px;
      }

      html, body { margin: 0; height: 100%; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }

      h2 { margin: 16px 12px 6px; font-size: 16px; font-weight: 700; color: #111827; }
      .section { margin-bottom: 18px; }

      .controls {
        padding: 12px;
        border-bottom: 1px solid #eee;
        display: flex; gap: 12px; align-items: flex-end; flex-wrap: wrap;
      }
      label { font-size: 12px; color: #555; }
      input, select, button { padding: 6px 8px; font-size: 14px; }

      .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; padding: 12px; }
      @media (max-width: 1100px) { .grid { grid-template-columns: 1fr; } }

      .card {
        display: grid; grid-template-rows: auto 1fr auto;
        border: 1px solid #e5e7eb; border-radius: 8px; overflow: hidden; background: #fff;
        box-shadow: 0 1px 2px rgba(0,0,0,0.04); min-height: 0;
      }
      .card header { padding: 10px 12px; border-bottom: 1px solid #f0f0f0; display: flex; align-items: center; gap: 8px; }
      .vendor { font-weight: 600; }
      .subtle { color: #6b7280; font-weight: 400; }
      .chart { width: 100%; height: 100%; }
      .chart-wrap { position: relative; height: 100%; min-height: 220px; }
      .loading { position: absolute; inset: 0; display: grid; place-items: center; background: rgba(255,255,255,0.7); font-size: 12px; color: #4b5563; z-index: 5; transition: opacity .2s ease; }
      .loading.hidden { opacity: 0; pointer-events: none; }

      .legend { position: absolute; top: 6px; left: 64px; z-index: 6; font-size: 12px; color: #111827; background: rgba(255,255,255,0.82); padding: 2px 6px; border-radius: 4px; box-shadow: 0 1px 1px rgba(0,0,0,0.05); }
      .legend .k { color: #6b7280; margin-right: 4px; }
      .legend .v { margin-right: 6px; }

      .stats { padding: 8px 12px; display: grid; grid-template-columns: auto auto 1fr; gap: 8px 16px; font-size: 12px; color: #444; border-top: 1px solid #f0f0f0; background: #fafafa; }
      .stat { display: flex; gap: 6px; align-items: baseline; }
      .stat.full { grid-column: 1 / -1; }
      .muted { color: #6b7280; }

      .card.embed .chart-wrap { min-height: 480px; }
      .card.embed .stats { display: none; }
      .card.embed .chart-wrap iframe { position: absolute; inset: 0; width: 100%; height: 100%; border: 0; }

      /* Streaming Speed Visual (goldrush only) */
      .sv { padding: 12px; }
      .sv-rows { display: grid; grid-template-columns: 64px 1fr; align-items: start; }
      .sv-label { font-size: 12px; color: var(--muted); text-transform: lowercase; }
      .sv-track { min-height: 96px; display: flex; flex-direction: column; justify-content: flex-end; }
      .sv-bars, .sv-labels { display: grid; grid-auto-flow: column; grid-auto-columns: var(--sv-bar-w); column-gap: var(--sv-gap); width: max-content; }
      .sv-bar { position: relative; width: auto; height: 72px; background: rgba(245,158,11,0.18); border-radius: 2px; overflow: hidden; outline: 1px solid var(--bucket-border); }
      .sv-fill { position: absolute; left: 0; bottom: 0; width: 100%; height: 0%; background: var(--goldrush); opacity: .78; }
      .sv-tick { font-size: 10px; color: var(--muted); text-align: center; writing-mode: vertical-rl; transform: rotate(180deg); height: 72px; overflow: hidden; }
      .sv-scroll { overflow-x: auto; overflow-y: hidden; background: var(--panel); border: 1px solid var(--bucket-border); border-radius: 12px; }
    </style>
    <script src="https://unpkg.com/lightweight-charts@4.2.3/dist/lightweight-charts.standalone.production.js"></script>
  </head>
  <body>
    <div class="section" id="section-sol">
      <h2>Solana</h2>
      <div class="controls">
        <div>
          <label>Pair Address</label><br/>
          <input id="pair-sol" size="48" placeholder="Pair address" />
        </div>
        <div>
          <label>Interval</label><br/>
          <select id="interval-sol">
            <option value="ONE_MINUTE" selected>ONE MINUTE</option>
            <option value="ONE_SECOND">ONE SECOND</option>
          </select>
        </div>
        <div>
          <label>Timeframe</label><br/>
          <select id="timeframe-sol">
            <option value="FIFTEEN_MINUTES">FIFTEEN MINUTES</option>
            <option value="ONE_HOUR" selected>ONE HOUR</option>
          </select>
        </div>
        <div>
          <button id="load-sol">Load Charts</button>
        </div>
      </div>
      <div class="grid">
        <div class="card" id="gold-card-sol">
          <header><span class="vendor">GoldRush</span> <span class="subtle" id="gold-token-sol"></span></header>
          <div class="chart-wrap"><div class="loading" id="gold-loading-sol">Loading…</div><div id="gold-chart-sol" class="chart"></div><div id="gold-legend-sol" class="legend"></div></div>
          <div class="stats">
            <div class="stat"><span class="muted">Last updated:</span> <span id="gold-last-sol">—</span></div>
            <div class="stat"><span class="muted">Refresh rate:</span> <span id="gold-refresh-sol">—</span></div>
            <div class="stat"><span class="muted">Candle age:</span> <span id="gold-latency-sol">—</span></div>
            <div class="stat full"><span class="muted">Last item:</span> <span id="gold-lastitem-sol">—</span></div>
          </div>
        </div>
        <div class="card embed">
          <header><span class="vendor">CoinGecko</span></header>
          <div class="chart-wrap"><div id="geckoterminal-embed"><iframe id="gecko-iframe-sol" title="GeckoTerminal Embed"></iframe></div></div>
          <div class="stats"><div class="stat full"><span class="muted">Note:</span> <span>Embedded chart (no sockets)</span></div></div>
        </div>

        <div class="card" style="grid-column: 1 / -1;">
          <header><span class="vendor">Streaming Speed Visual</span></header>
          <div class="sv sv-scroll">
            <div class="sv-rows">
              <div class="sv-label">goldrush</div>
              <div class="sv-track"><div class="sv-scroller"><div id="sv-gold-sol" class="sv-bars"></div><div id="sv-gold-labels-sol" class="sv-labels"></div></div></div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="section" id="section-hype">
      <h2>Hypercore</h2>
      <div class="controls">
        <div>
          <label>Token</label><br/>
          <input id="token-hype" size="32" placeholder="Symbol or token (e.g., HYPE)" />
        </div>
        <div>
          <label>Interval</label><br/>
          <select id="interval-hype">
            <option value="ONE_MINUTE" selected>ONE MINUTE</option>
            <option value="ONE_SECOND">ONE SECOND</option>
          </select>
        </div>
        <div>
          <label>Timeframe</label><br/>
          <select id="timeframe-hype">
            <option value="FIFTEEN_MINUTES">FIFTEEN MINUTES</option>
            <option value="ONE_HOUR" selected>ONE HOUR</option>
          </select>
        </div>
        <div>
          <button id="load-hype">Load Charts</button>
        </div>
      </div>
      <div class="grid">
        <div class="card" id="gold-card-hype">
          <header><span class="vendor">GoldRush</span> <span class="subtle" id="gold-token-hype"></span></header>
          <div class="chart-wrap"><div class="loading" id="gold-loading-hype">Loading…</div><div id="gold-chart-hype" class="chart"></div><div id="gold-legend-hype" class="legend"></div></div>
          <div class="stats">
            <div class="stat"><span class="muted">Last updated:</span> <span id="gold-last-hype">—</span></div>
            <div class="stat"><span class="muted">Refresh rate:</span> <span id="gold-refresh-hype">—</span></div>
            <div class="stat"><span class="muted">Candle age:</span> <span id="gold-latency-hype">—</span></div>
            <div class="stat full"><span class="muted">Last item:</span> <span id="gold-lastitem-hype">—</span></div>
          </div>
        </div>
        <div class="card embed">
          <header><span class="vendor">CoinGecko</span></header>
          <div class="chart-wrap"><div id="geckoterminal-embed"><iframe id="gecko-iframe-hype" title="GeckoTerminal Embed"></iframe></div></div>
          <div class="stats"><div class="stat full"><span class="muted">Note:</span> <span>Embedded chart (no sockets)</span></div></div>
        </div>

        <div class="card" style="grid-column: 1 / -1;">
          <header><span class="vendor">Streaming Speed Visual</span></header>
          <div class="sv sv-scroll">
            <div class="sv-rows">
              <div class="sv-label">goldrush</div>
              <div class="sv-track"><div class="sv-scroller"><div id="sv-gold-hype" class="sv-bars"></div><div id="sv-gold-labels-hype" class="sv-labels"></div></div></div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="section" id="section-base">
      <h2>Base</h2>
      <div class="controls">
        <div>
          <label>Pair Address</label><br/>
          <input id="pair-base" size="48" placeholder="Pair address" />
        </div>
        <div>
          <label>Interval</label><br/>
          <select id="interval-base">
            <option value="ONE_MINUTE" selected>ONE MINUTE</option>
            <option value="ONE_SECOND">ONE SECOND</option>
          </select>
        </div>
        <div>
          <label>Timeframe</label><br/>
          <select id="timeframe-base">
            <option value="FIFTEEN_MINUTES">FIFTEEN MINUTES</option>
            <option value="ONE_HOUR" selected>ONE HOUR</option>
          </select>
        </div>
        <div>
          <button id="load-base">Load Charts</button>
        </div>
      </div>
      <div class="grid">
        <div class="card" id="gold-card-base">
          <header><span class="vendor">GoldRush</span> <span class="subtle" id="gold-token-base"></span></header>
          <div class="chart-wrap"><div class="loading" id="gold-loading-base">Loading…</div><div id="gold-chart-base" class="chart"></div><div id="gold-legend-base" class="legend"></div></div>
          <div class="stats">
            <div class="stat"><span class="muted">Last updated:</span> <span id="gold-last-base">—</span></div>
            <div class="stat"><span class="muted">Refresh rate:</span> <span id="gold-refresh-base">—</span></div>
            <div class="stat"><span class="muted">Candle age:</span> <span id="gold-latency-base">—</span></div>
            <div class="stat full"><span class="muted">Last item:</span> <span id="gold-lastitem-base">—</span></div>
          </div>
        </div>
        <div class="card embed">
          <header><span class="vendor">CoinGecko</span></header>
          <div class="chart-wrap"><div id="geckoterminal-embed"><iframe id="gecko-iframe-base" title="GeckoTerminal Embed"></iframe></div></div>
          <div class="stats"><div class="stat full"><span class="muted">Note:</span> <span>Embedded chart (no sockets)</span></div></div>
        </div>

        <div class="card" style="grid-column: 1 / -1;">
          <header><span class="vendor">Streaming Speed Visual</span></header>
          <div class="sv sv-scroll">
            <div class="sv-rows">
              <div class="sv-label">goldrush</div>
              <div class="sv-track"><div class="sv-scroller"><div id="sv-gold-base" class="sv-bars"></div><div id="sv-gold-labels-base" class="sv-labels"></div></div></div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="section" id="section-bsc">
      <h2>BSC</h2>
      <div class="controls">
        <div>
          <label>Pair Address</label><br/>
          <input id="pair-bsc" size="48" placeholder="Pair address" />
        </div>
        <div>
          <label>Interval</label><br/>
          <select id="interval-bsc">
            <option value="ONE_MINUTE" selected>ONE MINUTE</option>
            <option value="ONE_SECOND">ONE SECOND</option>
          </select>
        </div>
        <div>
          <label>Timeframe</label><br/>
          <select id="timeframe-bsc">
            <option value="FIFTEEN_MINUTES">FIFTEEN MINUTES</option>
            <option value="ONE_HOUR" selected>ONE HOUR</option>
          </select>
        </div>
        <div>
          <button id="load-bsc">Load Charts</button>
        </div>
      </div>
      <div class="grid">
        <div class="card" id="gold-card-bsc">
          <header><span class="vendor">GoldRush</span> <span class="subtle" id="gold-token-bsc"></span></header>
          <div class="chart-wrap"><div class="loading" id="gold-loading-bsc">Loading…</div><div id="gold-chart-bsc" class="chart"></div><div id="gold-legend-bsc" class="legend"></div></div>
          <div class="stats">
            <div class="stat"><span class="muted">Last updated:</span> <span id="gold-last-bsc">—</span></div>
            <div class="stat"><span class="muted">Refresh rate:</span> <span id="gold-refresh-bsc">—</span></div>
            <div class="stat"><span class="muted">Candle age:</span> <span id="gold-latency-bsc">—</span></div>
            <div class="stat full"><span class="muted">Last item:</span> <span id="gold-lastitem-bsc">—</span></div>
          </div>
        </div>
        <div class="card embed">
          <header><span class="vendor">CoinGecko</span></header>
          <div class="chart-wrap"><div id="geckoterminal-embed"><iframe id="gecko-iframe-bsc" title="GeckoTerminal Embed"></iframe></div></div>
          <div class="stats"><div class="stat full"><span class="muted">Note:</span> <span>Embedded chart (no sockets)</span></div></div>
        </div>

        <div class="card" style="grid-column: 1 / -1;">
          <header><span class="vendor">Streaming Speed Visual</span></header>
          <div class="sv sv-scroll">
            <div class="sv-rows">
              <div class="sv-label">goldrush</div>
              <div class="sv-track"><div class="sv-scroller"><div id="sv-gold-bsc" class="sv-bars"></div><div id="sv-gold-labels-bsc" class="sv-labels"></div></div></div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      // Utils
      function utcMinute(tsSec) { return Math.floor(tsSec / 60) * 60; }
      function intervalToStepSec(interval) {
        switch (String(interval || '').toUpperCase()) {
          case 'ONE_SECOND': return 1;
          case 'ONE_MINUTE': return 60;
          case 'FIFTEEN_MINUTES': return 15 * 60;
          case 'THIRTY_MINUTES': return 30 * 60;
          case 'ONE_HOUR': return 60 * 60;
          default: return 60;
        }
      }
      function quantize(ts, step) { return Math.floor(ts / step) * step; }
      function fmtTime(tsSec) {
        if (!tsSec) return '—';
        const d = new Date(tsSec * 1000);
        const yyyy = d.getUTCFullYear();
        const mm = String(d.getUTCMonth() + 1).padStart(2, '0');
        const dd = String(d.getUTCDate()).padStart(2, '0');
        const HH = String(d.getUTCHours()).padStart(2, '0');
        const MM = String(d.getUTCMinutes()).padStart(2, '0');
        const SS = String(d.getUTCSeconds()).padStart(2, '0');
        return `${yyyy}-${mm}-${dd} ${HH}:${MM}:${SS} UTC`;
      }
      function fmtDelta(secondsSinceEpoch) {
        if (!secondsSinceEpoch) return '—';
        const now = Math.floor(Date.now() / 1000);
        const diff = Math.max(0, now - secondsSinceEpoch);
        const mm = Math.floor(diff / 60);
        const ss = diff % 60;
        return (mm > 0 ? mm + 'm ' : '') + ss + 's ago';
      }
      function fmtLatency(candleTs) {
        if (!candleTs) return '—';
        const now = Math.floor(Date.now() / 1000);
        const diff = Math.max(0, now - candleTs);
        const mm = Math.floor(diff / 60);
        const ss = diff % 60;
        return (mm > 0 ? mm + 'm ' : '') + ss + 's';
      }
      function fmtNum(n) { if (n == null || !isFinite(n)) return '—'; if (Math.abs(n) >= 100) return Number(n).toFixed(2); if (Math.abs(n) >= 1) return Number(n).toFixed(4); return Number(n).toFixed(6); }
      function fmtPrice(n) { if (n == null || !isFinite(n)) return '—'; return Number(n).toFixed(7); }
      function short(addr) { if (!addr) return ''; return addr.length > 12 ? addr.slice(0,6) + '…' + addr.slice(-4) : addr; }

      function createChart(container, legendEl) {
        const chart = LightweightCharts.createChart(container, {
          layout: { background: { color: '#ffffff' }, textColor: '#222' },
          leftPriceScale: { visible: true, borderVisible: true },
          rightPriceScale: { visible: true, borderVisible: true },
          timeScale: { borderVisible: false, timeVisible: true, secondsVisible: true, fixLeftEdge: true },
          crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
        });
        try {
          const resize = () => { const rect = container.getBoundingClientRect(); if (rect.width>0 && rect.height>0) chart.resize(Math.floor(rect.width), Math.floor(rect.height)); };
          new ResizeObserver(() => resize()).observe(container);
          window.addEventListener('resize', resize);
          resize();
        } catch {}
        chart.priceScale('left').applyOptions({ scaleMargins: { top: 0.05, bottom: 0.3 } });
        chart.priceScale('right').applyOptions({ scaleMargins: { top: 0.7, bottom: 0.05 } });
        const UP = '#26a69a';
        const DOWN = '#ef4444';
        const UPVOL = 'rgba(38,166,154,0.5)';
        const DOWNVOL = 'rgba(239,68,68,0.5)';
        const candles = chart.addCandlestickSeries({
          priceScaleId: 'left',
          priceFormat: { type: 'price', precision: 7, minMove: 0.0000001 },
          upColor: UP,
          borderUpColor: UP,
          wickUpColor: UP,
          downColor: DOWN,
          borderDownColor: DOWN,
          wickDownColor: DOWN,
        });
        const volumes = chart.addHistogramSeries({ priceScaleId: 'right', priceFormat: { type: 'volume' }, color: UPVOL });

        const barsByTime = new Map();
        function renderLegend(bar) {
          if (!legendEl) return; if (!bar) { legendEl.textContent = ''; return; }
          legendEl.innerHTML = `<span class="k">O</span><span class="v">${fmtPrice(bar.open)}</span>`+
                               `<span class="k">H</span><span class="v">${fmtPrice(bar.high)}</span>`+
                               `<span class="k">L</span><span class="v">${fmtPrice(bar.low)}</span>`+
                               `<span class="k">C</span><span class="v">${fmtPrice(bar.close)}</span>`+
                               `<span class="k">V</span><span class="v">${fmtNum(Number(bar.volume||0))}</span>`;
        }
        chart.subscribeCrosshairMove((param) => { if (!param || !param.time) { renderLegend(null); return; } const b = barsByTime.get(param.time); if (b) renderLegend(b); });
        return { chart, candles, volumes, barsByTime, renderLegend, upVolColor: UPVOL, downVolColor: DOWNVOL };
      }

      function setLastItem(el, c) { if (!el) return; if (!c) { el.textContent = '—'; return; } el.textContent = `t=${fmtTime(c.time)} | O ${fmtPrice(c.open)} H ${fmtPrice(c.high)} L ${fmtPrice(c.low)} C ${fmtPrice(c.close)}${c.volume!=null?` | V ${fmtNum(Number(c.volume))}`:''}`; }

      // Streaming speed helpers per chainKey
      function relayoutSpeed(chainKey) {
        try {
          const barsEl = document.getElementById(`sv-gold-${chainKey}`);
          const labelsEl = document.getElementById(`sv-gold-labels-${chainKey}`);
          const trackEl = barsEl?.closest('.sv-track');
          if (!barsEl || !labelsEl || !trackEl) return;

          const root = getComputedStyle(document.documentElement);
          const barWVar = (root.getPropertyValue('--sv-bar-w') || '3px').trim();
          const gapVar  = (root.getPropertyValue('--sv-gap')   || '3px').trim();
          const barWpx = Math.max(1, parseInt(barWVar, 10) || 3);
          const gapPx  = Math.max(0, parseInt(gapVar, 10)  || 3);

          const count = barsEl.children.length;
          const width = trackEl.clientWidth;
          const needed = count * barWpx + Math.max(0, count - 1) * gapPx;

          function setFit(colPx) {
            barsEl.style.gridAutoColumns = '';
            labelsEl.style.gridAutoColumns = '';
            barsEl.style.gridTemplateColumns = `repeat(${count}, ${colPx}px)`;
            labelsEl.style.gridTemplateColumns = `repeat(${count}, ${colPx}px)`;
            barsEl.style.columnGap = `${gapPx}px`;
            labelsEl.style.columnGap = `${gapPx}px`;
            barsEl.style.width = '100%';
            labelsEl.style.width = '100%';
          }
          function setNatural() {
            barsEl.style.gridTemplateColumns = '';
            labelsEl.style.gridTemplateColumns = '';
            barsEl.style.gridAutoColumns = `${barWpx}px`;
            labelsEl.style.gridAutoColumns = `${barWpx}px`;
            barsEl.style.columnGap = `${gapPx}px`;
            labelsEl.style.columnGap = `${gapPx}px`;
            barsEl.style.width = 'max-content';
            labelsEl.style.width = 'max-content';
          }

          if (width > 0 && count > 0 && needed < width) {
            const col = Math.max(barWpx, Math.floor((width - (count - 1) * gapPx) / count));
            setFit(col);
          } else {
            setNatural();
          }
        } catch {}
      }

      function ensureBarForGold(chainKey, minute) {
        const svBars = document.getElementById(`sv-gold-${chainKey}`);
        const svLabels = document.getElementById(`sv-gold-labels-${chainKey}`);
        if (!svBars || !svLabels) return null;
        const stateKey = `__svGold_${chainKey}`;
        const svState = window[stateKey] ||= { lastMinute: null, barsByMinute: new Map(), minutes: [], stepSec: 60 };
        if (svState.barsByMinute.has(minute)) return svState.barsByMinute.get(minute);

        let i = 0; while (i < svState.minutes.length && svState.minutes[i] < minute) i++;
        const bar = document.createElement('div'); bar.className = 'sv-bar';
        const fill = document.createElement('div'); fill.className = 'sv-fill'; bar.appendChild(fill);
        const tick = document.createElement('div'); tick.className = 'sv-tick';
        const d = new Date(minute * 1000);
        if (Number(svState.stepSec) === 1) {
          tick.textContent = `${String(d.getUTCHours()).padStart(2,'0')}:${String(d.getUTCMinutes()).padStart(2,'0')}:${String(d.getUTCSeconds()).padStart(2,'0')}`;
        } else {
          tick.textContent = `${String(d.getUTCHours()).padStart(2,'0')}:${String(d.getUTCMinutes()).padStart(2,'0')}`;
        }
        svBars.insertBefore(bar, svBars.children[i] || null);
        svLabels.insertBefore(tick, svLabels.children[i] || null);
        svState.minutes.splice(i, 0, minute);
        const entry = { bar, fill }; svState.barsByMinute.set(minute, entry);
        relayoutSpeed(chainKey);
        return entry;
      }

      function attachGold(wsUrl, views, state, els, chainKey) {
        const ws = new WebSocket(wsUrl);
        ws.onmessage = (ev) => {
          const msg = JSON.parse(ev.data);
          const nowSec = Math.floor(Date.now() / 1000);

          if (msg.type === 'snapshot') {
            const cs = (msg.candles || []).map(c => ({ time: c.time, open: c.open, high: c.high, low: c.low, close: c.close, volume: Number(c.volume || 0) }));
            if (cs.length) {
              views.candles.setData(cs);
              views.volumes.setData(cs.map(c => ({ time: c.time, value: c.volume, color: (c.close >= c.open ? views.upVolColor : views.downVolColor) })));
              for (const b of cs) views.barsByTime.set(b.time, b);
              try {
                // one-time zoom so the most recent portion occupies ~3/4 of the chart
                if (!state.zoomed) {
                  const last = cs[cs.length - 1];
                  const first = cs[0];
                  const span = Math.max(60, (last.time - first.time));
                  const from = last.time - Math.floor(span * 0.75);
                  views.chart.timeScale().setVisibleRange({ from, to: last.time });
                  state.zoomed = true;
                }
                views.chart.timeScale().scrollToRealTime();
              } catch {}
              state.lastCandle = cs[cs.length - 1].time; state.lastRecv = nowSec;
              state.lastScrollMinute = utcMinute(state.lastCandle || 0);
              els.loading.classList.add('hidden');
              setLastItem(els.lastItem, cs[cs.length - 1]);
              views.renderLegend(cs[cs.length - 1]);

              // build streaming-speed bars for snapshot
              const svBars = document.getElementById(`sv-gold-${chainKey}`);
              const svLabels = document.getElementById(`sv-gold-labels-${chainKey}`);
              if (svBars && svLabels) {
                svBars.innerHTML = ''; svLabels.innerHTML = '';
                const step = Number(state.stepSec || 60);
                window[`__svGold_${chainKey}`] = { lastMinute: null, barsByMinute: new Map(), minutes: [], stepSec: step };
                const buckets = cs.map(c => quantize(c.time, step));
                const uniqueBuckets = [...new Set(buckets)].sort((a,b)=>a-b);
                for (const b of uniqueBuckets) ensureBarForGold(chainKey, b);
                relayoutSpeed(chainKey);
              }
            }
          } else if (msg.type === 'update') {
            const c = { time: msg.candle.time, open: msg.candle.open, high: msg.candle.high, low: msg.candle.low, close: msg.candle.close, volume: Number(msg.candle.volume || 0) };
            views.candles.update(c); views.volumes.update({ time: c.time, value: c.volume, color: (c.close >= c.open ? views.upVolColor : views.downVolColor) }); views.barsByTime.set(c.time, c);
            state.lastCandle = c.time; state.lastRecv = nowSec; setLastItem(els.lastItem, c); els.loading.classList.add('hidden');
            views.renderLegend(c);
            // Reduce jitter: only auto-scroll when we roll over to a NEW minute
            try {
              const m = utcMinute(c.time);
              if (state.lastScrollMinute == null || m > state.lastScrollMinute) {
                views.chart.timeScale().scrollToRealTime();
                state.lastScrollMinute = m;
              }
            } catch {}

            const step = Number((window[`__svGold_${chainKey}`]?.stepSec) || 60);
            const bucket = quantize(c.time, step);
            const entry = ensureBarForGold(chainKey, bucket);
            if (entry && entry.fill) {
              const pct = Math.max(0, Math.min(100, ((nowSec - bucket) / step) * 100));
              entry.fill.style.height = pct + '%';
            }
            relayoutSpeed(chainKey);
          }
        };
        return ws;
      }

      function updateGeckoEmbed(token, chainSlug, iframeId, rangeMinutes, resolution) {
        try {
          const ch = (chainSlug || '').toLowerCase();
          const slug = ch.includes('hypercore') ? 'hyperliquid' : ch;
          const rng = (Number(rangeMinutes) > 0 ? `${Number(rangeMinutes)}m` : '60m');
          const res = (String(resolution||'1m').toLowerCase()==='1s' ? '1s' : '1m');
          const src = `https://www.geckoterminal.com/${encodeURIComponent(slug)}/pools/${encodeURIComponent(token)}?embed=1&info=0&swaps=0&grayscale=0&light_chart=1&chart_type=price&resolution=${res}&range=${rng}`;
          const iframe = document.getElementById(iframeId); if (iframe) iframe.src = src;
        } catch {}
      }

      function timeframeToMinutes(tf) {
        switch (String(tf || '').toUpperCase()) {
          case 'ONE_MINUTE': return 1;
          case 'FIFTEEN_MINUTES': return 15;
          case 'THIRTY_MINUTES': return 30;
          case 'ONE_HOUR': return 60;
          case 'FOUR_HOURS': return 240;
          case 'SIX_HOURS': return 360;
          case 'TWELVE_HOURS': return 720;
          case 'ONE_DAY': return 1440;
          case 'ONE_WEEK': return 10080;
          case 'ONE_MONTH': return 43200;
          default: return 60;
        }
      }
      function wireIntervalTimeframe(chainKey) {
        try {
          const intervalSel = document.getElementById(`interval-${chainKey}`);
          const timeframeSel = document.getElementById(`timeframe-${chainKey}`);
          if (!intervalSel || !timeframeSel) return;
          intervalSel.addEventListener('change', () => {
            const v = intervalSel.value;
            if (v === 'ONE_SECOND') {
              timeframeSel.value = 'FIFTEEN_MINUTES';
            }
          });
        } catch {}
      }

      // Per-chain controller
      function createChainController(chainKey, chainName) {
        const views = createChart(document.getElementById(`gold-chart-${chainKey}`), document.getElementById(`gold-legend-${chainKey}`));
        const state = { lastCandle: null, lastRecv: null, lastScrollMinute: null, zoomed: false, stepSec: 60 };
        let ws = null;

        async function load() {
          const pair = (document.getElementById(`pair-${chainKey}`).value || '').trim();
          if (!pair) { alert(`[${chainName}] Enter a pair address`); return; }
          try { if (ws) ws.close(); } catch {}
          state.lastCandle = state.lastRecv = null;
          document.getElementById(`gold-last-${chainKey}`).textContent = '—';
          document.getElementById(`gold-refresh-${chainKey}`).textContent = '—';
          document.getElementById(`gold-latency-${chainKey}`).textContent = '—';
          document.getElementById(`gold-token-${chainKey}`).textContent = `— (${chainName})`;
          document.getElementById(`gold-loading-${chainKey}`).classList.remove('hidden');
          document.getElementById(`sv-gold-${chainKey}`).innerHTML = '';
          document.getElementById(`sv-gold-labels-${chainKey}`).innerHTML = '';

          const interval  = document.getElementById(`interval-${chainKey}`).value || 'ONE_MINUTE';
          const timeframe = document.getElementById(`timeframe-${chainKey}`).value || 'ONE_HOUR';
          const wsScheme = location.protocol === 'https:' ? 'wss' : 'ws';
          const baseHost = location.host;

          const chainUpper = String(chainName || '').toUpperCase();
          const url = `${wsScheme}://${baseHost}/ws/goldrush?pair=${encodeURIComponent(pair)}&chain=${encodeURIComponent(chainUpper)}&interval=${encodeURIComponent(interval)}&timeframe=${encodeURIComponent(timeframe)}`;
          state.stepSec = intervalToStepSec(interval);
          ws = attachGold(url, views, state, {
            last: document.getElementById(`gold-last-${chainKey}`),
            refresh: document.getElementById(`gold-refresh-${chainKey}`),
            latency: document.getElementById(`gold-latency-${chainKey}`),
            lastItem: document.getElementById(`gold-lastitem-${chainKey}`),
            loading: document.getElementById(`gold-loading-${chainKey}`)
          }, chainKey);

          // meta listener for symbol
          if (ws) {
            ws.addEventListener('message', (ev) => { try { const m = JSON.parse(ev.data); if (m?.type === 'meta' && m.symbol) document.getElementById(`gold-token-${chainKey}`).textContent = `— ${m.symbol} (${chainName})`; } catch {} });
          }

          const tfMin = timeframeToMinutes(timeframe);
          const rangeMin = Math.max(15, Math.floor(tfMin * 0.75));
          const geckoRes = (interval === 'ONE_SECOND') ? '1s' : '1m';
          updateGeckoEmbed(pair, chainName, `gecko-iframe-${chainKey}`, rangeMin, geckoRes);
        }

        // metrics updater
        function tick() {
          const lastEl = document.getElementById(`gold-last-${chainKey}`);
          const refreshEl = document.getElementById(`gold-refresh-${chainKey}`);
          const latencyEl = document.getElementById(`gold-latency-${chainKey}`);
          if (state.lastRecv) {
            lastEl.textContent = `${fmtTime(state.lastRecv)} (candle ${fmtTime(state.lastCandle)})`;
            refreshEl.textContent = fmtDelta(state.lastRecv);
            latencyEl.textContent = fmtLatency(state.lastCandle);
          }
        }

        return { load, tick };
      }

      // Token-stream controller (for Hypercore)
      function createTokenChainController(chainKey, chainName) {
        const views = createChart(document.getElementById(`gold-chart-${chainKey}`), document.getElementById(`gold-legend-${chainKey}`));
        const state = { lastCandle: null, lastRecv: null, lastScrollMinute: null, zoomed: false, stepSec: 60 };
        let ws = null;

        async function load() {
          const token = (document.getElementById(`token-${chainKey}`).value || '').trim();
          if (!token) { alert(`[${chainName}] Enter a token`); return; }
          try { if (ws) ws.close(); } catch {}
          state.lastCandle = state.lastRecv = null;
          document.getElementById(`gold-last-${chainKey}`).textContent = '—';
          document.getElementById(`gold-refresh-${chainKey}`).textContent = '—';
          document.getElementById(`gold-latency-${chainKey}`).textContent = '—';
          document.getElementById(`gold-token-${chainKey}`).textContent = `— (${chainName})`;
          document.getElementById(`gold-loading-${chainKey}`).classList.remove('hidden');
          document.getElementById(`sv-gold-${chainKey}`).innerHTML = '';
          document.getElementById(`sv-gold-labels-${chainKey}`).innerHTML = '';

          const interval  = document.getElementById(`interval-${chainKey}`).value || 'ONE_MINUTE';
          const timeframe = document.getElementById(`timeframe-${chainKey}`).value || 'ONE_HOUR';
          const wsScheme = location.protocol === 'https:' ? 'wss' : 'ws';
          const baseHost = location.host;

          const url = `${wsScheme}://${baseHost}/ws/goldrush?token=${encodeURIComponent(token)}&chain=${encodeURIComponent(chainName.toUpperCase())}&interval=${encodeURIComponent(interval)}&timeframe=${encodeURIComponent(timeframe)}`;
          state.stepSec = intervalToStepSec(interval);
          ws = attachGold(url, views, state, {
            last: document.getElementById(`gold-last-${chainKey}`),
            refresh: document.getElementById(`gold-refresh-${chainKey}`),
            latency: document.getElementById(`gold-latency-${chainKey}`),
            lastItem: document.getElementById(`gold-lastitem-${chainKey}`),
            loading: document.getElementById(`gold-loading-${chainKey}`)
          }, chainKey);

          if (ws) { ws.addEventListener('message', (ev) => { try { const m = JSON.parse(ev.data); if (m?.type === 'meta' && m.symbol) document.getElementById(`gold-token-${chainKey}`).textContent = `— ${m.symbol} (${chainName})`; } catch {} }); }

          // Update CoinGecko embed dynamically; default HYPE -> proxy pool address for Hypercore
          let geckoToken = token;
          try {
            if ((chainName || '').toUpperCase().includes('HYPERCORE') && String(token).toUpperCase() === 'HYPE') {
              geckoToken = '0x0d01dc56dcaaca66ad901c959b4011ec';
            }
          } catch {}
          const tfMin = timeframeToMinutes(timeframe);
          const rangeMin = Math.max(15, Math.floor(tfMin * 0.75));
          const geckoRes = (interval === 'ONE_SECOND') ? '1s' : '1m';
          updateGeckoEmbed(geckoToken, chainName, `gecko-iframe-${chainKey}`, rangeMin, geckoRes);
        }

        function tick() {
          const lastEl = document.getElementById(`gold-last-${chainKey}`);
          const refreshEl = document.getElementById(`gold-refresh-${chainKey}`);
          const latencyEl = document.getElementById(`gold-latency-${chainKey}`);
          if (state.lastRecv) {
            lastEl.textContent = `${fmtTime(state.lastRecv)} (candle ${fmtTime(state.lastCandle)})`;
            refreshEl.textContent = fmtDelta(state.lastRecv);
            latencyEl.textContent = fmtLatency(state.lastCandle);
          }
        }

        return { load, tick };
      }

      const sol = createChainController('sol', 'SOLANA');
      const base = createChainController('base', 'BASE');
      const bsc = createChainController('bsc', 'BSC');
      const hype = createTokenChainController('hype', 'HYPERCORE_MAINNET');

      document.getElementById('load-sol').onclick = () => { sol.load(); relayoutSpeed('sol'); };
      document.getElementById('load-hype').onclick = () => { hype.load(); relayoutSpeed('hype'); };
      document.getElementById('load-base').onclick = () => { base.load(); relayoutSpeed('base'); };
      document.getElementById('load-bsc').onclick = () => { bsc.load(); relayoutSpeed('bsc'); };

      // defaults
      window.addEventListener('DOMContentLoaded', () => {
        document.getElementById('pair-sol').value = 'YrrUStgPugDp8BbfosqDeFssen6sA75ZS1QJvgnHtmY';
        document.getElementById('pair-base').value = '0x9c087Eb773291e50CF6c6a90ef0F4500e349B903';
        document.getElementById('pair-bsc').value = '0xcF59B8C8BAA2dea520e3D549F97d4e49aDE17057';
        document.getElementById('token-hype').value = 'HYPE';
        sol.load();
        hype.load();
        base.load();
        bsc.load();
        // initial relayout after first render
        setTimeout(() => { ['sol','hype','base','bsc'].forEach(relayoutSpeed); }, 0);
        ['sol','hype','base','bsc'].forEach(wireIntervalTimeframe);
      });

      // global metrics timer
      setInterval(() => { sol.tick(); base.tick(); bsc.tick(); hype.tick(); }, 1000);
      // relayout on resize
      window.addEventListener('resize', () => { ['sol','hype','base','bsc'].forEach(relayoutSpeed); });
    </script>
  </body>
  </html>


